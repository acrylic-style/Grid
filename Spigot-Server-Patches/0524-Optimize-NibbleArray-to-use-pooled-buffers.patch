From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 6 May 2020 23:30:30 -0400
Subject: [PATCH] Optimize NibbleArray to use pooled buffers

Massively reduces memory allocation of 2048 byte buffers by using
an object pool for these.

Uses lots of advanced new capabilities of the Paper codebase :)

diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index e625842e524f18e469f7695b27d52d4d04892266..49d95bb12083c306c8d257b202735066bad4388b 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -105,7 +105,11 @@ public class ChunkRegionLoader {
             if (flag) {
                 if (nbttagcompound2.hasKeyOfType("BlockLight", 7)) {
                     // Paper start - delay this task since we're executing off-main
-                    NibbleArray blockLight = new NibbleArray(nbttagcompound2.getByteArray("BlockLight"));
+                    // Pool safe get and clean
+                    NBTTagByteArray blockLightArray = nbttagcompound2.getByteArrayTag("BlockLight");
+                    // NibbleArray will copy the data in the ctor
+                    NibbleArray blockLight = new NibbleArray().markPoolSafe().cloneAndSet(blockLightArray.getBytesPoolSafe()); // This is going to light engine which handles releasing
+                    blockLightArray.cleanPooledBytes();
                     // Note: We move the block light nibble array creation here for perf & in case the compound is modified
                     tasksToExecuteOnMain.add(() -> {
                         lightengine.a(EnumSkyBlock.BLOCK, SectionPosition.a(chunkcoordintpair, b0), blockLight);
@@ -115,7 +119,11 @@ public class ChunkRegionLoader {
 
                 if (flag2 && nbttagcompound2.hasKeyOfType("SkyLight", 7)) {
                     // Paper start - delay this task since we're executing off-main
-                    NibbleArray skyLight = new NibbleArray(nbttagcompound2.getByteArray("SkyLight"));
+                    // Pool safe get and clean
+                    NBTTagByteArray skyLightArray = nbttagcompound2.getByteArrayTag("SkyLight");
+                    // NibbleArray will copy the data in the ctor
+                    NibbleArray skyLight = new NibbleArray().markPoolSafe().cloneAndSet(skyLightArray.getBytesPoolSafe()); // This is going to light engine which handles releasing
+                    skyLightArray.cleanPooledBytes();
                     // Note: We move the block light nibble array creation here for perf & in case the compound is modified
                     tasksToExecuteOnMain.add(() -> {
                         lightengine.a(EnumSkyBlock.SKY, SectionPosition.a(chunkcoordintpair, b0), skyLight);
@@ -387,11 +395,15 @@ public class ChunkRegionLoader {
                 }
 
                 if (nibblearray != null && !nibblearray.c()) {
-                    nbttagcompound2.setByteArray("BlockLight", nibblearray.asBytes());
+                    byte[] bytes = nibblearray.getCloneIfSet(); // Paper
+                    nbttagcompound2.setByteArray("BlockLight", bytes); // Paper
+                    MCUtil.registerCleaner(nbttagcompound2, bytes, NibbleArray::releaseBytes); // Paper - we can't really hook when this chunk is done without a ton of yuck efort, so just reclaim it once GC gets to it.
                 }
 
                 if (nibblearray1 != null && !nibblearray1.c()) {
-                    nbttagcompound2.setByteArray("SkyLight", nibblearray1.asBytes());
+                    byte[] bytes = nibblearray1.getCloneIfSet(); // Paper
+                    nbttagcompound2.setByteArray("SkyLight", bytes); // Paper
+                    MCUtil.registerCleaner(nbttagcompound2, bytes, NibbleArray::releaseBytes); // Paper - we can't really hook when this chunk is done without a ton of yuck efort, so just reclaim it once GC gets to it.
                 }
 
                 nbttaglist.add(nbttagcompound2);
diff --git a/src/main/java/net/minecraft/server/LightEngineStorage.java b/src/main/java/net/minecraft/server/LightEngineStorage.java
index 88277d23c36696fdd5363e41a130c9a443fac2c0..fa8039d38d5b3110fd85abf850248ba7948374c3 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorage.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorage.java
@@ -148,7 +148,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
     protected NibbleArray j(long i) {
         NibbleArray nibblearray = (NibbleArray) this.i.get(i);
 
-        return nibblearray != null ? nibblearray : new NibbleArray();
+        return nibblearray != null ? nibblearray : new NibbleArray().markPoolSafe(); // Paper
     }
 
     protected void a(LightEngineLayer<?, ?> lightenginelayer, long i) {
@@ -319,7 +319,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
         if (nibblearray != null) {
             this.i.put(i, nibblearray);
         } else {
-            this.i.remove(i);
+            NibbleArray remove = this.i.remove(i); if (remove != null && remove.cleaner != null) remove.cleaner.run(); // Paper - clean up when removed
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageArray.java b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
index 278aec8846d3bd448e359095063a711e78213ee5..f17b16d5c52cd77dd53807222dff4631d185e159 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageArray.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
@@ -27,7 +27,7 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
 
     public void a(long i) {
         if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Paper - avoid copying light data
-        this.data.queueUpdate(i, ((NibbleArray) this.data.getUpdating(i)).b()); // Paper - avoid copying light data
+        this.data.queueUpdate(i, new NibbleArray().markPoolSafe(this.data.getUpdating(i).getCloneIfSet())); // Paper - avoid copying light data - pool safe clone
         this.c();
     }
 
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageSky.java b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
index 06bc8371fe9de4d23fdd47e5a3919541bb399fd8..c15fbd8602d33955d8a625d4a86cdcd8ca7489f5 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
@@ -166,9 +166,9 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
                     j = SectionPosition.a(j, EnumDirection.UP);
                 }
 
-                return new NibbleArray((new NibbleArrayFlat(nibblearray1, 0)).asBytes());
+                return new NibbleArray().markPoolSafe(new NibbleArrayFlat(nibblearray1, 0).asBytes()); // Paper - mark pool use as safe (no auto cleaner)
             } else {
-                return new NibbleArray();
+                return new NibbleArray().markPoolSafe(); // Paper - mark pool use as safe (no auto cleaner)
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/NBTTagByteArray.java b/src/main/java/net/minecraft/server/NBTTagByteArray.java
index 034244c2465b9999c6fba63ab2310becef51b887..5310246ec97b8a78848214b152a67195fd8ddef9 100644
--- a/src/main/java/net/minecraft/server/NBTTagByteArray.java
+++ b/src/main/java/net/minecraft/server/NBTTagByteArray.java
@@ -17,10 +17,17 @@ public class NBTTagByteArray extends NBTList<NBTTagByte> {
             com.google.common.base.Preconditions.checkArgument( j < 1 << 24); // Spigot
 
             nbtreadlimiter.a(8L * (long) j);
-            byte[] abyte = new byte[j];
+            byte[] abyte = j == 2048 ? NibbleArray.BYTE_2048.acquire() : new byte[j]; // Paper - use nibble buffer if right size
 
             datainput.readFully(abyte);
-            return new NBTTagByteArray(abyte);
+            // Paper start - use pooled
+            NBTTagByteArray nbt = new NBTTagByteArray(abyte);
+            if (abyte.length == 2048) {
+                // register cleaner
+                nbt.cleaner = MCUtil.registerCleaner(nbt, abyte, NibbleArray::releaseBytes);
+            }
+            return nbt;
+            // Paper end
         }
 
         @Override
@@ -121,6 +128,35 @@ public class NBTTagByteArray extends NBTList<NBTTagByte> {
     }
 
     public byte[] getBytes() {
+        // Paper start
+        Runnable cleaner = this.cleaner;
+        if (cleaner != null) { // This will only be possible for 2048 byte arrays
+            // cleaners are thread safe if it tries to run twice, if getBytes is accessed concurrently, worse
+            // case is multiple clones
+            this.data = this.data.clone();
+            this.cleaner = null;
+            cleaner.run();
+        }
+        if (this.data == null) {
+            new Throwable("Horrible thing happened! Something hooked into Chunk Loading internals and accessed NBT after chunk was done loading. Please tell plugin to stop doing this, clone the memory before hand.").printStackTrace();
+        }
+        return this.data;
+    }
+    Runnable cleaner;
+    public void cleanPooledBytes() {
+        Runnable cleaner = this.cleaner;
+        if (cleaner != null) { // This will only be possible for 2048 byte arrays
+            this.cleaner = null;
+            this.data = null;
+            cleaner.run();
+        }
+    }
+    /**
+     * Use ONLY if you know the life of your usage of the bytes matches the life of the nbt node itself.
+     * If this NBT node can go unreachable before your usage of the bytes is over with, DO NOT use this
+     */
+    public byte[] getBytesPoolSafe() {
+        // Paper end
         return this.data;
     }
 
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index 02a2ed1baa3f82d302432b7bc627f3179751f886..5f38c962115f732fae20b61410dfc35b09248f4c 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -298,6 +298,20 @@ public class NBTTagCompound implements NBTBase {
         return new byte[0];
     }
 
+    // Paper start
+    public NBTTagByteArray getByteArrayTag(String s) {
+        try {
+            if (this.hasKeyOfType(s, 7)) {
+                return ((NBTTagByteArray) this.map.get(s));
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, NBTTagByteArray.a, classcastexception));
+        }
+
+        return new NBTTagByteArray(new byte[0]);
+    }
+    // Paper end
+
     public int[] getIntArray(String s) {
         try {
             if (this.hasKeyOfType(s, 11)) {
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
index 996c8326387b5a7fe62db6a76e000144565cb85b..073e16a4f08bf00b7d9187a5bfdfdbf84ed05593 100644
--- a/src/main/java/net/minecraft/server/NibbleArray.java
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -1,16 +1,73 @@
 package net.minecraft.server;
 
+import com.destroystokyo.paper.util.pooled.PooledObjects; // Paper
 import javax.annotation.Nullable;
 
 public class NibbleArray {
 
-    @Nullable
-    protected byte[] a;
+    // Paper start
+    public static byte[] EMPTY_NIBBLE = new byte[2048];
+    private static final int nibbleBucketSizeMultiplier = Integer.getInteger("Paper.nibbleBucketSize", 3072);
+    private static final int maxPoolSize = Integer.getInteger("Paper.maxNibblePoolSize", (int) Math.min(6, Math.max(1, Runtime.getRuntime().maxMemory() / 1024 / 1024 / 1024)) * (nibbleBucketSizeMultiplier * 8));
+    public static final PooledObjects<byte[]> BYTE_2048 = new PooledObjects<>(() -> new byte[2048], maxPoolSize);
+    public static void releaseBytes(byte[] bytes) {
+        if (bytes != null && bytes != EMPTY_NIBBLE && bytes.length == 2048) {
+            System.arraycopy(EMPTY_NIBBLE, 0, bytes, 0, 2048);
+            BYTE_2048.release(bytes);
+        }
+    }
+
+    public NibbleArray markPoolSafe(byte[] bytes) {
+        if (bytes != EMPTY_NIBBLE) this.a = bytes;
+        return markPoolSafe();
+    }
+    public NibbleArray markPoolSafe() {
+        poolSafe = true;
+        return this;
+    }
+    public byte[] getIfSet() {
+        return this.a != null ? this.a : EMPTY_NIBBLE;
+    }
+    public byte[] getCloneIfSet() {
+        if (a == null) {
+            return EMPTY_NIBBLE;
+        }
+        byte[] ret = BYTE_2048.acquire();
+        System.arraycopy(getIfSet(), 0, ret, 0, 2048);
+        return ret;
+    }
+
+    public NibbleArray cloneAndSet(byte[] bytes) {
+        if (bytes != null && bytes != EMPTY_NIBBLE) {
+            this.a = BYTE_2048.acquire();
+            System.arraycopy(bytes, 0, this.a, 0, 2048);
+        }
+        return this;
+    }
+    boolean poolSafe = false;
+    public java.lang.Runnable cleaner;
+    private void registerCleaner() {
+        if (!poolSafe) {
+            cleaner = MCUtil.registerCleaner(this, this.a, NibbleArray::releaseBytes);
+        } else {
+            cleaner = MCUtil.once(() -> NibbleArray.releaseBytes(this.a));
+        }
+    }
+    // Paper end
+    @Nullable protected byte[] a;
+
 
     public NibbleArray() {}
 
     public NibbleArray(byte[] abyte) {
+        // Paper start
+        this(abyte, false);
+    }
+    public NibbleArray(byte[] abyte, boolean isSafe) {
         this.a = abyte;
+        if (!isSafe) this.a = getCloneIfSet(); // Paper - clone for safety
+        registerCleaner();
+        // Paper end
         if (abyte.length != 2048) {
             throw (IllegalArgumentException) SystemUtils.c(new IllegalArgumentException("ChunkNibbleArrays should be 2048 bytes not: " + abyte.length));
         }
@@ -44,7 +101,8 @@ public class NibbleArray {
 
     public void a(int i, int j) { // PAIL: private -> public
         if (this.a == null) {
-            this.a = new byte[2048];
+            this.a = BYTE_2048.acquire(); // Paper
+            registerCleaner();// Paper
         }
 
         int k = this.d(i);
@@ -65,7 +123,8 @@ public class NibbleArray {
 
     public byte[] asBytes() {
         if (this.a == null) {
-            this.a = new byte[2048];
+            this.a = BYTE_2048.acquire(); // Paper
+            registerCleaner();// Paper
         }
 
         return this.a;
@@ -73,7 +132,7 @@ public class NibbleArray {
 
     public NibbleArray copy() { return this.b(); } // Paper - OBFHELPER
     public NibbleArray b() {
-        return this.a == null ? new NibbleArray() : new NibbleArray((byte[]) this.a.clone());
+        return this.a == null ? new NibbleArray() : new NibbleArray(this.a); // Paper - clone in ctor
     }
 
     public String toString() {
diff --git a/src/main/java/net/minecraft/server/NibbleArrayFlat.java b/src/main/java/net/minecraft/server/NibbleArrayFlat.java
index 67c960292db9d99ac85b5d0dda50ae48ef942c1b..f7641156beea365a91a935667abf8c9539896dc0 100644
--- a/src/main/java/net/minecraft/server/NibbleArrayFlat.java
+++ b/src/main/java/net/minecraft/server/NibbleArrayFlat.java
@@ -18,7 +18,7 @@ public class NibbleArrayFlat extends NibbleArray {
 
     @Override
     public byte[] asBytes() {
-        byte[] abyte = new byte[2048];
+        byte[] abyte = BYTE_2048.acquire(); // Paper
 
         for (int i = 0; i < 16; ++i) {
             System.arraycopy(this.a, 0, abyte, i * 128, 128);
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutLightUpdate.java b/src/main/java/net/minecraft/server/PacketPlayOutLightUpdate.java
index cd1ad45469aa163b9bc41774ae80adfa617fd97b..1946aae7424593100279834baa89c19f2522437f 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutLightUpdate.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutLightUpdate.java
@@ -16,13 +16,42 @@ public class PacketPlayOutLightUpdate implements Packet<PacketListenerPlayOut> {
     private List<byte[]> g;
     private List<byte[]> h;
 
+    // Paper start
+    java.lang.Runnable cleaner1;
+    java.lang.Runnable cleaner2;
+    java.util.concurrent.atomic.AtomicInteger remainingSends = new java.util.concurrent.atomic.AtomicInteger(0);
+
+    @Override
+    public void onPacketDispatch(EntityPlayer player) {
+        remainingSends.incrementAndGet();
+    }
+
+    @Override
+    public void onPacketDispatchFinish(EntityPlayer player, io.netty.channel.ChannelFuture future) {
+        if (remainingSends.decrementAndGet() <= 0) {
+            // incase of any race conditions, schedule this delayed
+            MCUtil.scheduleTask(1, () -> {
+                if (remainingSends.get() == 0) {
+                    cleaner1.run();
+                    cleaner2.run();
+                }
+            });
+        }
+    }
+
+    @Override
+    public boolean hasFinishListener() {
+        return true;
+    }
+
+    // Paper end
     public PacketPlayOutLightUpdate() {}
 
     public PacketPlayOutLightUpdate(ChunkCoordIntPair chunkcoordintpair, LightEngine lightengine) {
         this.a = chunkcoordintpair.x;
         this.b = chunkcoordintpair.z;
-        this.g = Lists.newArrayList();
-        this.h = Lists.newArrayList();
+        this.g = Lists.newArrayList();cleaner1 = MCUtil.registerListCleaner(this, this.g, NibbleArray::releaseBytes); // Paper
+        this.h = Lists.newArrayList();cleaner2 = MCUtil.registerListCleaner(this, this.h, NibbleArray::releaseBytes); // Paper
 
         for (int i = 0; i < 18; ++i) {
             NibbleArray nibblearray = lightengine.a(EnumSkyBlock.SKY).a(SectionPosition.a(chunkcoordintpair, -1 + i));
@@ -33,7 +62,7 @@ public class PacketPlayOutLightUpdate implements Packet<PacketListenerPlayOut> {
                     this.e |= 1 << i;
                 } else {
                     this.c |= 1 << i;
-                    this.g.add(nibblearray.asBytes().clone());
+                    this.g.add(nibblearray.getCloneIfSet()); // Paper
                 }
             }
 
@@ -42,7 +71,7 @@ public class PacketPlayOutLightUpdate implements Packet<PacketListenerPlayOut> {
                     this.f |= 1 << i;
                 } else {
                     this.d |= 1 << i;
-                    this.h.add(nibblearray1.asBytes().clone());
+                    this.h.add(nibblearray1.getCloneIfSet()); // Paper
                 }
             }
         }
@@ -54,8 +83,8 @@ public class PacketPlayOutLightUpdate implements Packet<PacketListenerPlayOut> {
         this.b = chunkcoordintpair.z;
         this.c = i;
         this.d = j;
-        this.g = Lists.newArrayList();
-        this.h = Lists.newArrayList();
+        this.g = Lists.newArrayList();cleaner1 = MCUtil.registerListCleaner(this, this.g, NibbleArray::releaseBytes); // Paper
+        this.h = Lists.newArrayList();cleaner2 = MCUtil.registerListCleaner(this, this.h, NibbleArray::releaseBytes); // Paper
 
         for (int k = 0; k < 18; ++k) {
             NibbleArray nibblearray;
@@ -63,7 +92,7 @@ public class PacketPlayOutLightUpdate implements Packet<PacketListenerPlayOut> {
             if ((this.c & 1 << k) != 0) {
                 nibblearray = lightengine.a(EnumSkyBlock.SKY).a(SectionPosition.a(chunkcoordintpair, -1 + k));
                 if (nibblearray != null && !nibblearray.c()) {
-                    this.g.add(nibblearray.asBytes().clone());
+                    this.g.add(nibblearray.getCloneIfSet()); // Paper
                 } else {
                     this.c &= ~(1 << k);
                     if (nibblearray != null) {
@@ -75,7 +104,7 @@ public class PacketPlayOutLightUpdate implements Packet<PacketListenerPlayOut> {
             if ((this.d & 1 << k) != 0) {
                 nibblearray = lightengine.a(EnumSkyBlock.BLOCK).a(SectionPosition.a(chunkcoordintpair, -1 + k));
                 if (nibblearray != null && !nibblearray.c()) {
-                    this.h.add(nibblearray.asBytes().clone());
+                    this.h.add(nibblearray.getCloneIfSet()); // Paper
                 } else {
                     this.d &= ~(1 << k);
                     if (nibblearray != null) {
