From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: acrylic-style <me@acrylicstyle.xyz>
Date: Thu, 11 Jun 2020 23:52:26 +0900
Subject: [PATCH] Fix Compilation Error


diff --git a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
index f98f4d55b14a59e06fb17a7f7500a2f98cba58a5..5f2acef8e40be03ee910b420f0fb8e876c4f245f 100644
--- a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
+++ b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
@@ -134,18 +134,22 @@ public class CraftPlayerProfile implements PlayerProfile {
 
     @Override
     public boolean completeFromCache() {
-        return completeFromCache(false);
+        MinecraftServer server = MinecraftServer.getServer();
+        return completeFromCache(false, server.getOnlineMode() || (SpigotConfig.bungee && PaperConfig.bungeeOnlineMode));
+    }
+
+    public boolean completeFromCache(boolean onlineMode) {
+        return complete(false, onlineMode);
     }
 
-    public boolean completeFromCache(boolean lookupName) {
+    public boolean completeFromCache(boolean lookupUUID, boolean onlineMode) {
         MinecraftServer server = MinecraftServer.getServer();
         String name = profile.getName();
         UserCache userCache = server.getUserCache();
         if (profile.getId() == null) {
             final GameProfile profile;
-            boolean isOnlineMode = server.getOnlineMode() || (SpigotConfig.bungee && PaperConfig.bungeeOnlineMode);
-            if (isOnlineMode) {
-                profile = lookupName ? userCache.getProfile(name) : userCache.getProfileIfCached(name);
+            if (onlineMode) {
+                profile = lookupUUID ? userCache.getProfile(name) : userCache.getProfileIfCached(name);
             } else {
                 // Make an OfflinePlayer using an offline mode UUID since the name has no profile
                 profile = new GameProfile(UUID.nameUUIDFromBytes(("OfflinePlayer:" + name).getBytes(Charsets.UTF_8)), name);
@@ -170,17 +174,20 @@ public class CraftPlayerProfile implements PlayerProfile {
 
     public boolean complete(boolean textures) {
         MinecraftServer server = MinecraftServer.getServer();
+        return complete(textures, server.getOnlineMode() || (SpigotConfig.bungee && PaperConfig.bungeeOnlineMode));
+    }
+    public boolean complete(boolean textures, boolean onlineMode) {
+        MinecraftServer server = MinecraftServer.getServer();
 
-        boolean isOnlineMode = server.getOnlineMode() || (SpigotConfig.bungee && PaperConfig.bungeeOnlineMode);
-        boolean isCompleteFromCache = this.completeFromCache(true);
-        if (isOnlineMode && (!isCompleteFromCache || textures && !hasTextures())) {
+        boolean isCompleteFromCache = this.completeFromCache(false, onlineMode);
+        if (onlineMode && (!isCompleteFromCache || textures && !hasTextures())) {
             GameProfile result = server.getSessionService().fillProfileProperties(profile, true);
             if (result != null) {
                 copyProfileProperties(result, this.profile, true);
             }
             server.getUserCache().saveProfile(this.profile);
         }
-        return profile.isComplete() && (!isOnlineMode || !textures || hasTextures());
+        return profile.isComplete() && (!onlineMode || !textures || hasTextures());
     }
 
     private static void copyProfileProperties(GameProfile source, GameProfile target) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index fdc78d5707679272ac4d9399986baec428d615d2..3c5e8026b80de78f05292ffbb9140473cab90c56 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -175,33 +175,33 @@ public abstract class PlayerList {
         final ChunkCoordIntPair pos = new ChunkCoordIntPair(chunkX, chunkZ);
         PlayerChunkMap playerChunkMap = finalWorldserver.getChunkProvider().playerChunkMap;
         playerChunkMap.chunkDistanceManager.addTicketAtLevel(TicketType.LOGIN, pos, 31, pos.pair());
-        worldserver.getChunkProvider().markAreaHighPriority(pos, 28, 3);
-        worldserver.getChunkProvider().getChunkAtAsynchronously(chunkX, chunkZ, true, false).thenApply(chunk -> {
+        finalWorldserver.getChunkProvider().markAreaHighPriority(pos, 28, 3);
+            finalWorldserver.getChunkProvider().getChunkAtAsynchronously(chunkX, chunkZ, true, false).thenApply(chunk2 -> {
             PlayerChunk updatingChunk = playerChunkMap.getUpdatingChunk(pos.pair());
             if (updatingChunk != null) {
                 return updatingChunk.getEntityTickingFuture();
             } else {
                 return CompletableFuture.completedFuture(chunk);
             }
-        }).thenAccept(chunk -> {
+        }).thenAccept(chunk3 -> {
             playerconnection.playerJoinReady = () -> {
                 postChunkLoadJoin(
                     entityplayer, finalWorldserver, networkmanager, playerconnection,
                     nbttagcompound, networkmanager.getSocketAddress().toString(), lastKnownName
                 );
             };
-        }));
+        });
         // boost the priorities
-        worldserver.asyncChunkTaskManager.raisePriority(chunkX, chunkZ, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
+            finalWorldserver.asyncChunkTaskManager.raisePriority(chunkX, chunkZ, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
         for (int cx = -1; cx <= 1; cx++) {
             for (int cz = -1; cz <= 1; cz++) {
                 if (cx == 0 && cz == 0) continue;
                 // we have to directly request it otherwise the task won't be started yet to boost priority
-                worldserver.getChunkProvider().getFullChunkAsync(chunkX + cx, chunkZ + cz, null);
-                worldserver.asyncChunkTaskManager.raisePriority(chunkX + cx, chunkZ + cz, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
+                finalWorldserver.getChunkProvider().getFullChunkAsync(chunkX + cx, chunkZ + cz, null);
+                finalWorldserver.asyncChunkTaskManager.raisePriority(chunkX + cx, chunkZ + cz, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
             }
         }
-    }
+    }));}
 
     EntityPlayer getActivePlayer(UUID uuid) {
         EntityPlayer player = this.getUUIDMap().get(uuid);
@@ -261,7 +261,7 @@ public abstract class PlayerList {
             // Paper start - Recipients for join and quit messages. (SPIGOT-809)
             IChatBaseComponent[] chatMessage = CraftChatMessage.fromString(joinMessage);
             server.sendMessage(chatmessage);
-            playerJoinEvent.getRecipients().forEach(new Consumer<Player>() {
+            playerJoinEvent.getRecipients().forEach(new java.util.function.Consumer<Player>() {
                 @Override
                 public void accept(Player player) {
                     ((org.bukkit.craftbukkit.entity.CraftPlayer) player).getHandle().sendMessage(chatMessage);
