From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: acrylic-style <me@acrylicstyle.xyz>
Date: Thu, 30 Apr 2020 19:24:40 +0900
Subject: [PATCH] SPIGOT-809 Recipients for join and quit messages.

https://hub.spigotmc.org/jira/projects/SPIGOT/issues/SPIGOT-809

diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index eeb870107031b38e25b5fb85ea731a7db1d6c2d1..c2f074d9559460961b38d1a224beff7c3bfc4d1e 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -12,6 +12,7 @@ import java.util.Collections;
 import java.util.Iterator;
 import java.util.Optional;
 import java.util.Set;
+import java.util.function.Consumer;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import org.apache.commons.lang3.StringEscapeUtils;
@@ -49,6 +50,7 @@ import org.bukkit.event.player.PlayerInteractEntityEvent;
 import org.bukkit.event.player.PlayerItemHeldEvent;
 import org.bukkit.event.player.PlayerKickEvent;
 import org.bukkit.event.player.PlayerMoveEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerResourcePackStatusEvent;
 import org.bukkit.event.player.PlayerSwapHandItemsEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
@@ -1586,9 +1588,18 @@ public class PlayerConnection implements PacketListenerPlayIn {
         */
 
         this.player.p();
-        String quitMessage = this.minecraftServer.getPlayerList().disconnect(this.player);
-        if ((quitMessage != null) && (quitMessage.length() > 0)) {
-            this.minecraftServer.getPlayerList().sendMessage(CraftChatMessage.fromString(quitMessage));
+        PlayerQuitEvent quitMessage = this.minecraftServer.getPlayerList().disconnect(this.player);
+        IChatBaseComponent[] chatMessage = CraftChatMessage.fromString(quitMessage.getQuitMessage());
+        if (this.player.didPlayerJoinEvent && (quitMessage.getQuitMessage() != null) && (quitMessage.getQuitMessage().length() > 0)) { // Paper - don't print quit if we never printed join
+            // Paper start - Recipients for join and quit messages. (SPIGOT-809)
+            quitMessage.getRecipients().forEach(new Consumer<Player>() {
+                @Override
+                public void accept(Player player) {
+                    ((org.bukkit.craftbukkit.entity.CraftPlayer) player).getHandle().sendMessage(chatMessage);
+                }
+            });
+            // Paper end
+            this.minecraftServer.getPlayerList().sendMessage(CraftChatMessage.fromString(quitMessage.getQuitMessage()));
         }
         // CraftBukkit end
         if (this.isExemptPlayer()) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 35d7ac60f61ffb493fe4f32b63511b2b86805243..e83dc93c8b5b0859a38ac459e5ee4e4e5c18ebe5 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -19,6 +19,7 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -197,25 +198,37 @@ public abstract class PlayerList {
         WorldServer finalWorldserver1 = worldserver1;
         int chunkX = loc.getBlockX() >> 4;
         int chunkZ = loc.getBlockZ() >> 4;
+        WorldServer finalWorldserver2 = worldserver;
+        worldserver.getChunkProvider().getTickingChunkAsync(chunkX, chunkZ, (chunk -> { // use ticking - as it has at least 1 neighbours loaded
         final ChunkCoordIntPair pos = new ChunkCoordIntPair(chunkX, chunkZ);
         PlayerChunkMap playerChunkMap = finalWorldserver.getChunkProvider().playerChunkMap;
         playerChunkMap.chunkDistanceManager.addTicketAtLevel(TicketType.LOGIN, pos, 31, pos.pair());
-        worldserver.getChunkProvider().markAreaHighPriority(pos, 28, 3);
-        worldserver.getChunkProvider().getChunkAtAsynchronously(chunkX, chunkZ, true, false).thenApply(chunk -> {
+        finalWorldserver2.getChunkProvider().markAreaHighPriority(pos, 28, 3);
+        finalWorldserver2.getChunkProvider().getChunkAtAsynchronously(chunkX, chunkZ, true, false).thenApply(chunk2 -> {
             PlayerChunk updatingChunk = playerChunkMap.getUpdatingChunk(pos.pair());
             if (updatingChunk != null) {
                 return updatingChunk.getEntityTickingFuture();
             } else {
                 return CompletableFuture.completedFuture(chunk);
             }
-        }).thenAccept(chunk -> {
+        }).thenAccept(chunk3 -> { // Paper - compile fix
             playerconnection.playerJoinReady = () -> {
                 postChunkLoadJoin(
                     entityplayer, finalWorldserver, finalWorldserver1, networkmanager, playerconnection,
                     nbttagcompound, networkmanager.getSocketAddress().toString(), lastKnownName
                 );
             };
-        });
+        });})); // Paper - patch fix
+        // boost the priorities
+        worldserver.asyncChunkTaskManager.raisePriority(chunkX, chunkZ, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
+        for (int cx = -1; cx <= 1; cx++) {
+            for (int cz = -1; cz <= 1; cz++) {
+                if (cx == 0 && cz == 0) continue;
+                // we have to directly request it otherwise the task won't be started yet to boost priority
+                worldserver.getChunkProvider().getFullChunkAsync(chunkX + cx, chunkZ + cz, null);
+                worldserver.asyncChunkTaskManager.raisePriority(chunkX + cx, chunkZ + cz, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
+            }
+        }
     }
 
     EntityPlayer getActivePlayer(UUID uuid) {
@@ -273,7 +286,16 @@ public abstract class PlayerList {
 
         if (joinMessage != null && joinMessage.length() > 0) {
             // Paper start - Removed sendAll for loop and broadcasted to console also
-            server.getPlayerList().sendMessage(CraftChatMessage.fromString(joinMessage));
+            // Paper start - Recipients for join and quit messages. (SPIGOT-809)
+            IChatBaseComponent[] chatMessage = CraftChatMessage.fromString(joinMessage);
+            server.sendMessage(chatmessage, SystemUtils.getNullUUID());
+            playerJoinEvent.getRecipients().forEach(new Consumer<Player>() {
+                @Override
+                public void accept(Player player) {
+                    ((org.bukkit.craftbukkit.entity.CraftPlayer) player).getHandle().sendMessage(chatMessage);
+                }
+            });
+            // Paper end
             // Paper end
         }
         // CraftBukkit end
@@ -490,7 +512,7 @@ public abstract class PlayerList {
 
     }
 
-    public String disconnect(EntityPlayer entityplayer) { // CraftBukkit - return string
+    public PlayerQuitEvent disconnect(EntityPlayer entityplayer) { // CraftBukkit - return string // Paper - return PlayerQuitEvent
         WorldServer worldserver = entityplayer.getWorldServer();
 
         entityplayer.a(StatisticList.LEAVE_GAME);
@@ -576,7 +598,7 @@ public abstract class PlayerList {
         cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
         // CraftBukkit end
 
-        return entityplayer.didPlayerJoinEvent ? playerQuitEvent.getQuitMessage() : null; // CraftBukkit // Paper - don't print quit if we never printed join
+        return playerQuitEvent; // CraftBukkit // Paper - don't print quit if we never printed join // Paper - return PlayerQuitEvent
     }
 
     // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
